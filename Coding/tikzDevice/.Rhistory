P[is.na(P)] = 0
rm(Prob)
rm(Data)
# ====================================================================== #
# Compute the lower probability for an order.
# ====================================================================== #
grid <- expand.grid(d = unique(P$D),
z = unique(P$Z))
grid$reference <- 1 + grid$d
# Let j be the ordering that is being considered.
# Let k be the row of grid that is being considered.
# I will take a particular ordering and then create a list for that
# ordering. The list will consist of one slice for each row of the grid,
# and will be the set A that I have defined in the text.
a = function(j){
output <- list()
for(k in 1:nrow(grid)){
output[[k]] <- which(Order[j,] <=
Order[j,grid$reference[k]]) - 1
}
return(output)
}
b = function(j){
intermediate <- a(j)
output <- vector(length=nrow(grid))
for(k in 1:nrow(grid)){
output[k] <- sum(P[P$Y == 0 & P$D %in% unlist(intermediate[k]) &
P$Z == grid$z[k],]$p)
}
return(output)
}
lower = function(){
output <- list()
for(j in 1:nrow(Order)){
intermediate <- cbind(grid,b(j))
colnames(intermediate) <- c(colnames(grid),"inequal")
intermediate <- ddply(intermediate,.(d),summarize,bound=max(inequal))
output[[j]] <- intermediate
}
return(output)
}
bound.l <- lower()
rm(list=c("a","b","lower"))
# ====================================================================== #
# Compute the upper probability for an order.
# ====================================================================== #
a = function(j){
output <- list()
for(k in 1:nrow(grid)){
output[[k]] <- which(Order[j,] >=
Order[j,grid$reference[k]]) - 1
}
return(output)
}
b = function(j){
intermediate <- a(j)
output <- vector(length=nrow(grid))
for(k in 1:nrow(grid)){
output[k] <- sum(P[P$Y == 1 & P$D %in% unlist(intermediate[k]) &
P$Z == grid$z[k],]$p)
}
return(output)
}
upper = function(){
output <- list()
for(j in 1:nrow(Order)){
intermediate <- cbind(grid,b(j))
colnames(intermediate) <- c(colnames(grid),"inequal")
intermediate <- ddply(intermediate,.(d),summarize,bound=1-max(inequal))
output[[j]] <- intermediate
}
return(output)
}
bound.u <- upper()
rm(list=c("a","b","upper"))
# ====================================================================== #
# Store them all in one list.
# ====================================================================== #
a = function(r,s){
bound <- list()
for(k in 1:length(r)){
bound[[k]] <- merge(r[k],s[k],by=c("d"),all=T)
colnames(bound[[k]]) <- c("d","lower","upper")
}
return(bound)
}
b = function(r){
for(k in 1:length(r)){
s = data.frame(r[k])
r[[k]] <- ifelse(prod(s$upper >= (s$lower-tol)) == 0,NA,r[k])
}
return(r)
}
bound <- a(bound.l,bound.u)
bound <- b(bound)
rm(list=c("a","b"))
# ====================================================================== #
# Remove bounds that do not satisfy the ordering.
# ====================================================================== #
a = function(r){
Store <- list()
for(j in 1:length(r[is.na(r)==F])){
s <- data.frame(r[is.na(r)==F][j])
s <- s[with(s, order(d)),]
s <- cbind(s,Order[is.na(r)==F,])
colnames(s) <- c("d","lower","upper","order")
Store[[j]] <- s
}
return(Store)
}
bound.x1 <- a(bound)
rm(a)
# ======================================================================= #
# ======================================================================= #
# ======================================================================= #
# Do again for X=2.
# ======================================================================= #
# ======================================================================= #
# ======================================================================= #
# Specify the support of X.
X = 2
# I will consider whether a mother is white or not.
library(iterpc)
# Get all possible strict orderings of p(d,x).
a = iterpc(2*X, 2*X, ordered = T, replace = T)
Order <- data.frame(getall(a))
Output <- matrix(nrow=nrow(Order),ncol=4)
for(j in 1:nrow(Order)){
Output[j,] = as.numeric(factor(as.numeric(Order[j,])))
}
Order <- unique(Output)
rm(Output)
rm(a)
# Rename columns of Order.
a = as.vector(outer(0:1, 1:X-1, paste, sep=""))
a = as.vector(paste("f",a,sep="."))
colnames(Order) <- a
rm(a)
# Redefine X in letters to match naming convention of Order.
X = letters[1:X]
# ======================================================================= #
# Get a grid for (Y,D,X,Z) and fill in probabilities.
# ======================================================================= #
Data <- D[,c("workedm","morekids","hispm","multi2nd")]
colnames(Data) <- c("Y","D","X","Z")
P <- expand.grid(Y=unique(Data$Y),
D=unique(Data$D),
X=unique(Data$X),
Z=unique(Data$Z))
library(plyr)
a <- count(Data)
b <- count(Data,c("X","Z"))
colnames(a) <- c(colnames(a[,1:4]),"Total")
Prob <- merge(a,b,by=c("X","Z"),all=T)
Prob$p <- Prob$Total/Prob$freq
Prob <- Prob[,c(1:4,7)]
rm(a)
rm(b)
P <- merge(P,Prob,by=c("Y","D","X","Z"),all=T)
P[is.na(P)] = 0
rm(Prob)
# ====================================================================== #
# Compute the lower probability for an order.
# ====================================================================== #
grid <- expand.grid(d = unique(P$D),
x = unique(P$X),
eta = unique(P$X),
z = unique(P$Z))
grid$reference <- 1 + grid$d + 2*grid$x
# Let j be the ordering that is being considered.
# Let k be the row of grid that is being considered.
# I will take a particular ordering and then create a list for that
# ordering. The list will consist of one slice for each row of the grid,
# and will be the set A that I have defined in the text.
a = function(j){
output <- list()
for(k in 1:nrow(grid)){
q = grid[k,]$eta
output[[k]] <- which(Order[j,((1+2*q):(2+2*q))] <=
Order[j,grid$reference[k]]) - 1
}
return(output)
}
b = function(j){
intermediate <- a(j)
output <- vector(length=nrow(grid))
for(k in 1:nrow(grid)){
output[k] <- sum(P[P$Y == 0 & P$D %in% unlist(intermediate[k]) &
P$X == grid$eta[k] & P$Z == grid$z[k],]$p)
}
return(output)
}
lower = function(){
output <- list()
for(j in 1:nrow(Order)){
intermediate <- cbind(grid,b(j))
colnames(intermediate) <- c(colnames(grid),"inequal")
intermediate <- ddply(intermediate,.(d,x),summarize,bound=max(inequal))
output[[j]] <- intermediate
}
return(output)
}
bound.l <- lower()
rm(list=c("a","b","lower"))
# ====================================================================== #
# Compute the upper probability for an order.
# ====================================================================== #
a = function(j){
output <- list()
for(k in 1:nrow(grid)){
q = grid[k,]$eta
output[[k]] <- which(Order[j,((1+2*q):(2+2*q))] >=
Order[j,grid$reference[k]]) - 1
}
return(output)
}
b = function(j){
intermediate <- a(j)
output <- vector(length=nrow(grid))
for(k in 1:nrow(grid)){
output[k] <- sum(P[P$Y == 1 & P$D %in% unlist(intermediate[k]) &
P$X == grid$eta[k] & P$Z == grid$z[k],]$p)
}
return(output)
}
upper = function(){
output <- list()
for(j in 1:nrow(Order)){
intermediate <- cbind(grid,b(j))
colnames(intermediate) <- c(colnames(grid),"inequal")
intermediate <- ddply(intermediate,.(d,x),summarize,bound=1-max(inequal))
output[[j]] <- intermediate
}
return(output)
}
bound.u <- upper()
rm(list=c("a","b","upper"))
# ====================================================================== #
# Store them all in one list.
# ====================================================================== #
a = function(r,s){
bound <- list()
for(k in 1:length(r)){
bound[[k]] <- merge(r[k],s[k],by=c("d","x"),all=T)
colnames(bound[[k]]) <- c("d","x","lower","upper")
}
return(bound)
}
b = function(r){
for(k in 1:length(r)){
s = data.frame(r[k])
r[[k]] <- ifelse(prod(s$upper >= (s$lower-tol)) == 0,NA,r[k])
}
return(r)
}
bound <- a(bound.l,bound.u)
bound <- b(bound)
rm(list=c("a","b"))
# ====================================================================== #
# Remove bounds that do not satisfy the ordering.
# ====================================================================== #
a = function(r){
Store <- list()
for(j in 1:length(r[is.na(r)==F])){
s <- data.frame(r[is.na(r)==F][j])
s <- s[with(s, order(x,d)),]
s <- cbind(s,Order[is.na(r)==F,][j,])
colnames(s) <- c("d","x","lower","upper","order")
Store[[j]] <- s
}
return(Store)
}
b = function(r){
Store <- list()
for(j in 1:length(r[is.na(r)==F])){
s <- data.frame(r[is.na(r)==F][j])
s <- s[with(s, order(x,d)),]
s <- cbind(s,Order[is.na(r)==F,])
colnames(s) <- c("d","x","lower","upper","order")
Store[[j]] <- s
}
return(Store)
}
bound <- if(length(bound[is.na(bound)==F])>1){
a(bound)} else{
b(bound)}
rm(a)
rm(b)
# ====================================================================== #
# Remove bounds that do not satisfy the ordering (externally invalid).
# ====================================================================== #
a = function(r){
Store <- vector(length = length(r[is.na(r)==F]))
for(j in 1:length(r[is.na(r)==F])){
s <- data.frame(r[is.na(r)==F][j])
s <- arrange(s,order)
bash <- vector(length = nrow(s))
for(k in 1:nrow(s)){
bash[k] <- prod(s$upper[k]<=s[s$order>s$order[k],3])
}
Store[j] = prod(bash)
}
return(Store)
}
b <- which(a(bound)==1)
bound <- bound[b]
rm(a)
rm(b)
# ====================================================================== #
# Find the weighted bound.
# ====================================================================== #
a <- count(Data,"X")
a$p <- a$freq/sum(a$freq)
a <- a[,c(1,3)]
colnames(a) <- c("x","p")
b = function(r,s){
Store <- list()
for(j in 1:length(r)){
q = merge(data.frame(r[j]),s)
q = cbind(q[,1:4],q[,6])
colnames(q) <- c("x","d","l","u","p")
q$lower <- q$p*q$l
q$upper <- q$p*q$u
q <- q[,c(1,2,6,7)]
q <- ddply(q,.(d),summarize,lower=sum(lower),upper=sum(upper))
Store[[j]] <- q
}
return(Store)
}
Bound <- b(bound,a)
rm(a)
rm(b)
bound.x1
bound
Bound
0.2717473-0.5239242
0.4695478-0.5239242
c(0.2673045,0.4713467)-0.5236072
c(0.2717473,0.4695478)-0.5239242
load("~/GitHub/Covariatesets/Coding/ACEdata.RData")
ACE
require(tikzDevice)
options(tikzMetricPackages = c("\\usepackage[utf8]{inputenc}",
"\\usepackage[T1]{fontenc}", "\\usetikzlibrary{calc}",
"\\usepackage{amssymb}"))
tikz('instruments.tex')
p <- ggplot(ACE, aes(xmin=cl,xmax=cu,ymin=Exp-0.4,ymax=Exp+0.4))
p + theme_bw() +
theme(text = element_text(family = "CM Roman"),
axis.text.x = element_text(size = 10),
axis.text.y = element_text(size = 10),
axis.title.x = element_text(size = 12),
axis.title.y = element_text(size = 12)) +
theme(plot.background = element_blank(),
panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),
panel.border = element_rect(colour = 'black'),
panel.background = element_blank(),
axis.line = element_line(colour = 'black')) +
theme(legend.position="none") +
geom_rect(aes(xmin=cl,xmax=cu,ymin=Exp-0.4,ymax=Exp+0.4),fill="red") +
geom_rect(aes(xmin=lower,xmax=upper,ymin=Exp-0.4,ymax=Exp+0.4),fill="blue",alpha=0.5) +
#   geom_vline(xintercept = 0) +
scale_x_continuous(breaks = round(seq(min(ACE$lower), max(ACE$upper), by = 0.1),1)) +
scale_y_continuous(breaks = round(seq(min(ACE$Exp), max(ACE$Exp), by = 1),1)) +
xlab("$ACE_n(D\\rightarrow Y)$")
dev.off()
require(ggplot2)
require(tikzDevice)
options(tikzMetricPackages = c("\\usepackage[utf8]{inputenc}",
"\\usepackage[T1]{fontenc}", "\\usetikzlibrary{calc}",
"\\usepackage{amssymb}"))
tikz('instruments.tex')
p <- ggplot(ACE, aes(xmin=cl,xmax=cu,ymin=Exp-0.4,ymax=Exp+0.4))
p + theme_bw() +
theme(text = element_text(family = "CM Roman"),
axis.text.x = element_text(size = 10),
axis.text.y = element_text(size = 10),
axis.title.x = element_text(size = 12),
axis.title.y = element_text(size = 12)) +
theme(plot.background = element_blank(),
panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),
panel.border = element_rect(colour = 'black'),
panel.background = element_blank(),
axis.line = element_line(colour = 'black')) +
theme(legend.position="none") +
geom_rect(aes(xmin=cl,xmax=cu,ymin=Exp-0.4,ymax=Exp+0.4),fill="red") +
geom_rect(aes(xmin=lower,xmax=upper,ymin=Exp-0.4,ymax=Exp+0.4),fill="blue",alpha=0.5) +
#   geom_vline(xintercept = 0) +
scale_x_continuous(breaks = round(seq(min(ACE$lower), max(ACE$upper), by = 0.1),1)) +
scale_y_continuous(breaks = round(seq(min(ACE$Exp), max(ACE$Exp), by = 1),1)) +
xlab("$ACE_n(D\\rightarrow Y)$")
dev.off()
require(ggplot2)
require(tikzDevice)
options(tikzMetricPackages = c("\\usepackage[utf8]{inputenc}",
"\\usepackage[T1]{fontenc}", "\\usetikzlibrary{calc}",
"\\usepackage{amssymb}"))
tikz('instruments.tex')
p <- ggplot(ACE, aes(xmin=cl,xmax=cu,ymin=Exp-0.4,ymax=Exp+0.4))
p + theme_bw() +
theme(text = element_text(family = "CM Roman"),
axis.text.x = element_text(size = 10),
axis.text.y = element_text(size = 10),
axis.title.x = element_text(size = 12),
axis.title.y = element_text(size = 12)) +
theme(plot.background = element_blank(),
panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),
panel.border = element_rect(colour = 'black'),
panel.background = element_blank(),
axis.line = element_line(colour = 'black')) +
theme(legend.position="none") +
geom_rect(aes(xmin=cl,xmax=cu,ymin=Exp-0.4,ymax=Exp+0.4),fill="red") +
geom_rect(aes(xmin=lower,xmax=upper,ymin=Exp-0.4,ymax=Exp+0.4),fill="blue") +
#   geom_vline(xintercept = 0) +
scale_x_continuous(breaks = round(seq(min(ACE$lower), max(ACE$upper), by = 0.1),1)) +
scale_y_continuous(breaks = round(seq(min(ACE$Exp), max(ACE$Exp), by = 1),1)) +
xlab("$ACE_n(D\\rightarrow Y)$")
dev.off()
load("~/GitHub/Covariatesets/Coding/tikzDevice/Data for instrument graphs.RData")
require(tikzDevice)
options(tikzMetricPackages = c("\\usepackage[utf8]{inputenc}",
"\\usepackage[T1]{fontenc}", "\\usetikzlibrary{calc}",
"\\usepackage{amssymb}"))
tikz('allin.tex')
p <- ggplot(df1, aes(xmin=cl0,xmax=cu0,ymin=cl1,ymax=cu1))
p + theme_bw() +
theme(text = element_text(family = "CM Roman"),
axis.text.x = element_text(size = 10),
axis.text.y = element_text(size = 10),
axis.title.x = element_text(size = 12),
axis.title.y = element_text(size = 12)) +
theme(plot.background = element_blank(),
panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),
panel.border = element_rect(colour = 'black'),
panel.background = element_blank(),
axis.line = element_line(colour = 'black')) +
theme(legend.position="none") +
geom_rect(data=df2,aes(xmin=cl0,xmax=cu0,ymin=cl1,ymax=cu1),fill="red") +
#   geom_rect(data=df2,aes(xmin=u0,xmax=cu0,ymin=cl1,ymax=cu1),fill="red") +
#   geom_rect(data=df2,aes(xmin=l0,xmax=u0,ymin=cl1,ymax=l1),fill="red") +
#   geom_rect(data=df2,aes(xmin=l0,xmax=u0,ymin=u1,ymax=cu1),fill="red") +
geom_line(aes(x=c(0.537,0.716),y=0.476),color="blue") +
scale_x_continuous(breaks = round(seq(0.371, 0.723, by = 0.1),1)) +
scale_y_continuous(breaks = round(seq(0.186, 0.777, by = 0.1),1)) +
xlab("$\\mathbb{E}_n[Y(0)]$") +
ylab("$\\mathbb{E}_n[Y(1)]$")
dev.off()
# File to input is located at F:\Documents and photos\Masters work\test2.tex
# Check out Yihui and the vignette
ACE
require(tikzDevice)
options(tikzMetricPackages = c("\\usepackage[utf8]{inputenc}",
"\\usepackage[T1]{fontenc}", "\\usetikzlibrary{calc}",
"\\usepackage{amssymb}"))
tikz('multiple.tex')
p <- ggplot(df1, aes(xmin=cl0,xmax=cu0,ymin=cl1,ymax=cu1))
p + theme_bw() +
theme(text = element_text(family = "CM Roman"),
axis.text.x = element_text(size = 10),
axis.text.y = element_text(size = 10),
axis.title.x = element_text(size = 12),
axis.title.y = element_text(size = 12)) +
theme(plot.background = element_blank(),
panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),
panel.border = element_rect(colour = 'black'),
panel.background = element_blank(),
axis.line = element_line(colour = 'black')) +
theme(legend.position="none") +
geom_rect(data=df,aes(xmin=cl0,xmax=cu0,ymin=cl1,ymax=cu1),fill="red") +
#   geom_rect(data=df,aes(xmin=u0,xmax=cu0,ymin=cl1,ymax=cu1),fill="red",alpha=0.5) +
#   geom_rect(data=df,aes(xmin=l0,xmax=u0,ymin=cl1,ymax=l1),fill="red",alpha=0.5) +
#   geom_rect(data=df,aes(xmin=l0,xmax=u0,ymin=u1,ymax=cu1),fill="red",alpha=0.5) +
geom_line(aes(x=c(0.529,0.733),y=0.476),color="blue") +
scale_x_continuous(breaks = round(seq(0.371, 0.723, by = 0.1),1)) +
scale_y_continuous(breaks = round(seq(0.186, 0.777, by = 0.1),1)) +
xlab("$\\mathbb{E}_n[Y(0)]$") +
ylab("$\\mathbb{E}_n[Y(1)]$")
dev.off()
require(tikzDevice)
options(tikzMetricPackages = c("\\usepackage[utf8]{inputenc}",
"\\usepackage[T1]{fontenc}", "\\usetikzlibrary{calc}",
"\\usepackage{amssymb}"))
tikz('samesex.tex')
p <- ggplot(df1, aes(xmin=cl0,xmax=cu0,ymin=cl1,ymax=cu1))
p + theme_bw() +
theme(text = element_text(family = "CM Roman"),
axis.text.x = element_text(size = 10),
axis.text.y = element_text(size = 10),
axis.title.x = element_text(size = 12),
axis.title.y = element_text(size = 12)) +
theme(plot.background = element_blank(),
panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),
panel.border = element_rect(colour = 'black'),
panel.background = element_blank(),
axis.line = element_line(colour = 'black')) +
theme(legend.position="none") +
geom_rect(aes(xmin=cl0,xmax=cu0,ymin=cl1,ymax=cu1),fill="red") +
#   geom_rect(aes(xmin=u0,xmax=cu0,ymin=cl1,ymax=cu1),fill="red",alpha=0.5) +
#   geom_rect(aes(xmin=l0,xmax=u0,ymin=cl1,ymax=l1),fill="red",alpha=0.5) +
#   geom_rect(aes(xmin=l0,xmax=u0,ymin=u1,ymax=cu1),fill="red",alpha=0.5) +
geom_rect(aes(xmin=l0,xmax=u0,ymin=l1,ymax=u1),fill="blue") +
scale_x_continuous(breaks = round(seq(min(df1$cl0), max(df1$cu0), by = 0.1),1)) +
scale_y_continuous(breaks = round(seq(min(df1$cl1), max(df1$cu1), by = 0.1),1)) +
xlab("$\\mathbb{E}_n[Y(0)]$") +
ylab("$\\mathbb{E}_n[Y(1)]$")
dev.off()
