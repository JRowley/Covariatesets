g <- cbind(g, rowMaxs(g))
# Compute k.auxiliary by finding the gamma quantile of the ordered maxima.
gamma.value <- floor(gamma * R)
k.aux <- sort(g[,3])[gamma.value]
rm(gamma.value)
# Compute the set hat{V}_n.
Check <- data.frame(1-Regression$coefficients)
colnames(Check) <- c("Coefficient")
Check$min.term <- c(
Check[1,1] + k.aux * s1,
Check[2,1] + k.aux * s2)
Check$min <- c(
min(Check$min.term) + 2 * k.aux * s1,
min(Check$min.term) + 2 * k.aux * s2)
Check$Satisfied <- ifelse(Check$Coefficient <= Check$min, 1, 0)
stop("Code should terminate here and the set hat{V}_n should be found")
# At this point we know which values of v lie in hat{V}_n.
Computation <- matrix(nrow = R, ncol = (Check$Satisfied==1)%*%(rep(1,2)))
j = 1
for(i in 1:nrow(Check)){
if(Check$Satisfied[i] == 1){
Computation[,j] <- g[,i]
j <- j + 1
}
else
print("Not in set")
}
Computation <- cbind(Computation, rowMaxs(Computation))
# Order the final column and find the appropriate quantile.
k.prime <- sort(Computation[,ncol(Computation)])[floor(R*p)]
Bounding <- vector(length = nrow(Check))
for(i in 1:length(Bounding)){
Bounding[i] <- Check$Coefficient[i] + (1/sqrt(nrow(Useful))) * k.prime * adjustment[i]
}
Bound <- min(Bounding)
U.RHO.0 <- Bound
U.RHO.0
rm(list=c("Check","Computation","Draws","g","Regression"))
# =======================================================================================
# LOWER BOUND ON RHO.0
# =======================================================================================
# Set gamma_n.
gamma <- 1 - 0.1/log(nrow(Useful))
# Simulate R draws from the 2-variate standard normal distribution.
R <- 10000000
Draws <- rmvnorm(R, mean = rep(0, 2), sigma = diag(2))
# Set the appropriate quantile of the confidence region.
alpha <- 0.05
# By Bonferroni's inequality, we have that the 'adjusted' level should be 1-alpha/n.
p <- 1-alpha/4
# Define a variable Y that takes the value 1 whenever workedm == 1.
Useful$Y <- ifelse(Useful$workedm == 1, 1, 0)
# Define variables (X1,X2) that indicate the events (V=1,V=2).
Useful$X1 <- ifelse(Useful$multi2nd == 0, 1, 0)
Useful$X2 <- ifelse(Useful$multi2nd == 1, 1, 0)
# Regress Y on (X1,X2) and compute estimated covariance matrix for the parameters.
Regression <- lm(Y ~ 0 + X1 + X2, data = Useful)
# Find variance matrix.
vcov(Regression)
# Adjust the variance matrix by n to get the large sample variance.
Variance <- vcov(Regression) * nrow(Useful)
# Compute ghat(v) for each v.
g1 <- sqrt(Variance)[, 1]
g2 <- sqrt(Variance)[, 2]
# Compute s(v) for each v.
s1 <- sqrt(sum(g1^2))/sqrt(nrow(Useful))
s2 <- sqrt(sum(g2^2))/sqrt(nrow(Useful))
# Compute the gamma quantile.
g <- data.frame(Draws %*% g1)
colnames(g) <- "v1"
g$v2 <- Draws %*% g2
adjustment <- c(sqrt(sum(g1^2)), sqrt(sum(g2^2)))
# Adjust each column by the norm.
g$v1 <- g$v1/adjustment[1]
g$v2 <- g$v2/adjustment[2]
# Find the maximum over each row.
g <- as.matrix(g)
g <- cbind(g, rowMaxs(g))
# Compute k.auxiliary by finding the gamma quantile of the ordered maxima.
gamma.value <- floor(gamma * R)
k.aux <- sort(g[,3])[gamma.value]
rm(gamma.value)
# Compute the set hat{V}_n.
Check <- data.frame(-Regression$coefficients)
colnames(Check) <- c("Coefficient")
Check$min.term <- c(
Check[1,1] + k.aux * s1,
Check[2,1] + k.aux * s2)
Check$min <- c(
min(Check$min.term) + 2 * k.aux * s1,
min(Check$min.term) + 2 * k.aux * s2)
Check$Satisfied <- ifelse(Check$Coefficient <= Check$min, 1, 0)
stop("Code should terminate here and the set hat{V}_n should be found")
# At this point we know which values of v lie in hat{V}_n.
Computation <- matrix(nrow = R, ncol = (Check$Satisfied==1)%*%(rep(1,2)))
j = 1
for(i in 1:nrow(Check)){
if(Check$Satisfied[i] == 1){
Computation[,j] <- g[,i]
j <- j + 1
}
else
print("Not in set")
}
Computation <- cbind(Computation, rowMaxs(Computation))
# Order the final column and find the appropriate quantile.
k.prime <- sort(Computation[,ncol(Computation)])[floor(R*p)]
Bounding <- vector(length = nrow(Check))
for(i in 1:length(Bounding)){
Bounding[i] <- Check$Coefficient[i] + (1/sqrt(nrow(Useful))) * k.prime * adjustment[i]
}
Bound <- min(Bounding)
L.RHO.0 <- -1 * Bound
L.RHO.0
rm(list=c("Check","Computation","Draws","g","Regression"))
# =======================================================================================
# UPPER BOUND ON RHO.0+RHO.1
# =======================================================================================
# Set gamma_n.
gamma <- 1 - 0.1/log(nrow(Useful))
# Simulate R draws from the 2-variate standard normal distribution.
R <- 10000000
Draws <- rmvnorm(R, mean = rep(0, 2), sigma = diag(2))
# Set the appropriate quantile of the confidence region.
alpha <- 0.05
# By Bonferroni's inequality, we have that the 'adjusted' level should be 1-alpha/n.
p <- 1-alpha/4
# Define a variable Y that takes the value 1 whenever workedm == 1.
Useful$Y <- ifelse(Useful$workedm == 1, 1, 0)
# Define variables (X1,X2) that indicate the events (V=1,V=2).
Useful$X1 <- ifelse(Useful$multi2nd == 0, 1, 0)
Useful$X2 <- ifelse(Useful$multi2nd == 1, 1, 0)
# Regress Y on (X1,X2) and compute estimated covariance matrix for the parameters.
Regression <- lm(Y ~ 0 + X1 + X2, data = Useful)
# Find variance matrix.
vcov(Regression)
# Adjust the variance matrix by n to get the large sample variance.
Variance <- vcov(Regression) * nrow(Useful)
# Compute ghat(v) for each v.
g1 <- sqrt(Variance)[, 1]
g2 <- sqrt(Variance)[, 2]
# Compute s(v) for each v.
s1 <- sqrt(sum(g1^2))/sqrt(nrow(Useful))
s2 <- sqrt(sum(g2^2))/sqrt(nrow(Useful))
# Compute the gamma quantile.
g <- data.frame(Draws %*% g1)
colnames(g) <- "v1"
g$v2 <- Draws %*% g2
adjustment <- c(sqrt(sum(g1^2)), sqrt(sum(g2^2)))
# Adjust each column by the norm.
g$v1 <- g$v1/adjustment[1]
g$v2 <- g$v2/adjustment[2]
# Find the maximum over each row.
g <- as.matrix(g)
g <- cbind(g, rowMaxs(g))
# Compute k.auxiliary by finding the gamma quantile of the ordered maxima.
gamma.value <- floor(gamma * R)
k.aux <- sort(g[,3])[gamma.value]
rm(gamma.value)
# Compute the set hat{V}_n.
Check <- data.frame(Regression$coefficients)
colnames(Check) <- c("Coefficient")
Check$min.term <- c(
Check[1,1] + k.aux * s1,
Check[2,1] + k.aux * s2)
Check$min <- c(
min(Check$min.term) + 2 * k.aux * s1,
min(Check$min.term) + 2 * k.aux * s2)
Check$Satisfied <- ifelse(Check$Coefficient <= Check$min, 1, 0)
stop("Code should terminate here and the set hat{V}_n should be found")
# At this point we know which values of v lie in hat{V}_n.
Computation <- matrix(nrow = R, ncol = (Check$Satisfied==1)%*%(rep(1,2)))
j = 1
for(i in 1:nrow(Check)){
if(Check$Satisfied[i] == 1){
Computation[,j] <- g[,i]
j <- j + 1
}
else
print("Not in set")
}
Computation <- cbind(Computation, rowMaxs(Computation))
# Order the final column and find the appropriate quantile.
k.prime <- sort(Computation[,ncol(Computation)])[floor(R*p)]
Bounding <- vector(length = nrow(Check))
for(i in 1:length(Bounding)){
Bounding[i] <- Check$Coefficient[i] + (1/sqrt(nrow(Useful))) * k.prime * adjustment[i]
}
Bound <- min(Bounding)
U.RHO.01 <- Bound
U.RHO.01
rm(list=c("Check","Computation","Draws","g","Regression"))
# =======================================================================================
# LOWER BOUND ON RHO.0+RHO.1
# =======================================================================================
# Set gamma_n.
gamma <- 1 - 0.1/log(nrow(Useful))
# Simulate R draws from the 2-variate standard normal distribution.
R <- 10000000
Draws <- rmvnorm(R, mean = rep(0, 2), sigma = diag(2))
# Set the appropriate quantile of the confidence region.
alpha <- 0.05
# By Bonferroni's inequality, we have that the 'adjusted' level should be 1-alpha/n.
p <- 1-alpha/4
# Define a variable Y that takes the value 1 whenever workedm == 1 & morekids == 1.
Useful$Y <- ifelse(Useful$workedm == 1 & Useful$morekids == 1, 1, 0)
# Define variables (X1,X2) that indicate the events (V=1,V=2).
Useful$X1 <- ifelse(Useful$multi2nd == 0, 1, 0)
Useful$X2 <- ifelse(Useful$multi2nd == 1, 1, 0)
# Regress Y on (X1,X2) and compute estimated covariance matrix for the parameters.
Regression <- lm(Y ~ 0 + X1 + X2, data = Useful)
# Find variance matrix.
vcov(Regression)
# Adjust the variance matrix by n to get the large sample variance.
Variance <- vcov(Regression) * nrow(Useful)
# Compute ghat(v) for each v.
g1 <- sqrt(Variance)[, 1]
g2 <- sqrt(Variance)[, 2]
# Compute s(v) for each v.
s1 <- sqrt(sum(g1^2))/sqrt(nrow(Useful))
s2 <- sqrt(sum(g2^2))/sqrt(nrow(Useful))
# Compute the gamma quantile.
g <- data.frame(Draws %*% g1)
colnames(g) <- "v1"
g$v2 <- Draws %*% g2
adjustment <- c(sqrt(sum(g1^2)), sqrt(sum(g2^2)))
# Adjust each column by the norm.
g$v1 <- g$v1/adjustment[1]
g$v2 <- g$v2/adjustment[2]
# Find the maximum over each row.
g <- as.matrix(g)
g <- cbind(g, rowMaxs(g))
# Compute k.auxiliary by finding the gamma quantile of the ordered maxima.
gamma.value <- floor(gamma * R)
k.aux <- sort(g[,3])[gamma.value]
rm(gamma.value)
# Compute the set hat{V}_n.
Check <- data.frame(-Regression$coefficients)
colnames(Check) <- c("Coefficient")
Check$min.term <- c(
Check[1,1] + k.aux * s1,
Check[2,1] + k.aux * s2)
Check$min <- c(
min(Check$min.term) + 2 * k.aux * s1,
min(Check$min.term) + 2 * k.aux * s2)
Check$Satisfied <- ifelse(Check$Coefficient <= Check$min, 1, 0)
stop("Code should terminate here and the set hat{V}_n should be found")
# At this point we know which values of v lie in hat{V}_n.
Computation <- matrix(nrow = R, ncol = (Check$Satisfied==1)%*%(rep(1,2)))
j = 1
for(i in 1:nrow(Check)){
if(Check$Satisfied[i] == 1){
Computation[,j] <- g[,i]
j <- j + 1
}
else
print("Not in set")
}
Computation <- cbind(Computation, rowMaxs(Computation))
# Order the final column and find the appropriate quantile.
k.prime <- sort(Computation[,ncol(Computation)])[floor(R*p)]
Bounding <- vector(length = nrow(Check))
for(i in 1:length(Bounding)){
Bounding[i] <- Check$Coefficient[i] + (1/sqrt(nrow(Useful))) * k.prime * adjustment[i]
}
Bound <- min(Bounding)
L.RHO.01 <- -1 * Bound
L.RHO.01
rm(list=c("Check","Computation","Draws","g","Regression"))
# =======================================================================================
# RESULTS
# =======================================================================================
L.RHO.0
U.RHO.0
L.RHO.01
U.RHO.01
# ======================================================================== #
# Load data into R
# ======================================================================== #
Source <- url("http://www.ucl.ac.uk/~zctpep9/Data%20archive/AE98Data.RData")
DF <- load(Source)
PUMS80M <- D
rm(list = c("Source","DF","D"))
# ======================================================================== #
# Define RZ
# ======================================================================== #
# Z takes the value 1 if multi2nd == 1
# Z takes the value 0 if multi2nd == 0
PUMS80M$Z <- PUMS80M$multi2nd
# ======================================================================== #
# Define RX
# ======================================================================== #
# X takes the value 1 if whitem == 1
# X takes the value 2 if blackm == 1
# X takes the value 3 if othracem == 1
PUMS80M$X <- PUMS80M$whitem +
2*PUMS80M$blackm +
3*PUMS80M$othracem
# ======================================================================== #
# Select relevant data
# ======================================================================== #
Data <- data.frame(Y = PUMS80M$workedm,
D = PUMS80M$morekids,
X = PUMS80M$X,
Z = PUMS80M$Z)
rm(PUMS80M)
# ======================================================================== #
# Define probability space
# ======================================================================== #
library(plyr)
Grid <- expand.grid(unique(Data$Y),
unique(Data$D),
unique(Data$X),
unique(Data$Z))
colnames(Grid) <- c("Y","D","X","Z")
Calc <- function(j){
W = ifelse(Data$Y == Grid$Y[j] & Data$D == Grid$D[j],1,0)
V = ifelse(Data$X == Grid$X[j] & Data$Z == Grid$Z[j],1,0)
R <- lm(W ~ 0 + V)
return(R$coefficients[[1]])
}
Store <- vector(length = nrow(Grid))
for(j in 1:nrow(Grid)){
Store[j] = Calc(j)
}
Grid$f <- Store
rm(j)
rm(Store)
# ======================================================================== #
# Define bounds
# ======================================================================== #
Bounds.neg <- expand.grid(unique(Data$X),
unique(Data$Z))
colnames(Bounds.neg) <- c("X","Z")
Calc <- function(j){
A = vector(length = 4)
# Lower bound Y(0)
W = ifelse(Data$Y == 0,1,0)
V = ifelse(Data$X == Bounds.neg$X[j] & Data$Z == Bounds.neg$Z[j],1,0)
A[1] <- lm(W ~ 0 + V)$coefficients[[1]]
# Upper bound Y(0)
W = ifelse(Data$Y == 0 & Data$D == 0,0,1)
V = ifelse(Data$X == Bounds.neg$X[j] & Data$Z == Bounds.neg$Z[j],1,0)
A[2] <- lm(W ~ 0 + V)$coefficients[[1]]
# Lower bound Y(1)
W = ifelse(Data$Y == 1 & Data$D == 1,1,0)
V = ifelse(Data$X == Bounds.neg$X[j] & Data$Z == Bounds.neg$Z[j],1,0)
A[3] <- lm(W ~ 0 + V)$coefficients[[1]]
# Upper bound Y(1)
W = ifelse(Data$Y == 1,1,0)
V = ifelse(Data$X == Bounds.neg$X[j] & Data$Z == Bounds.neg$Z[j],1,0)
A[4] <- lm(W ~ 0 + V)$coefficients[[1]]
return(A)
}
Store <- matrix(nrow = nrow(Bounds.neg),ncol = 4)
for(j in 1:nrow(Bounds.neg)){
Store[j,] = Calc(j)
}
Bounds.neg$l0 <- Store[,1]
Bounds.neg$u0 <- Store[,2]
Bounds.neg$l1 <- Store[,3]
Bounds.neg$u1 <- Store[,4]
rm(j)
rm(Store)
# ======================================================================== #
# Define constraints
# ======================================================================== #
Set <- matrix(nrow = length(unique(Bounds.neg$X)), ncol = 5)
for(j in 1:length(unique(Bounds.neg$X))){
k = unique(Bounds.neg$X)[j]
Set[j,1] <- k
Set[j,2] <- max(Bounds.neg[Bounds.neg$X==k,"l0"])
Set[j,3] <- min(Bounds.neg[Bounds.neg$X==k,"u0"])
Set[j,4] <- max(Bounds.neg[Bounds.neg$X==k,"l1"])
Set[j,5] <- min(Bounds.neg[Bounds.neg$X==k,"u1"])
}
Constraints.neg <- as.data.frame(Set)
rm(Set)
colnames(Constraints.neg) <- c(colnames(Bounds.neg)[-2])
# ======================================================================== #
# Plot
# ======================================================================== #
Plot.data <- Constraints.neg[,1:4]
Plot.data <- melt(Plot.data, id=c("X","l1"))
Plot.data <- Plot.data[,-3]
ggplot(Plot.data, aes(y=l1,x=value,group=X)) +
geom_line(aes(col=X))
detach("package:mvtnorm", unload=TRUE)
detach("package:matrixStats", unload=TRUE)
library("reshape", lib.loc="~/R/win-library/3.1")
library("ggplot2", lib.loc="~/R/win-library/3.1")
# ======================================================================== #
# Load data into R
# ======================================================================== #
Source <- url("http://www.ucl.ac.uk/~zctpep9/Data%20archive/AE98Data.RData")
DF <- load(Source)
PUMS80M <- D
rm(list = c("Source","DF","D"))
# ======================================================================== #
# Define RZ
# ======================================================================== #
# Z takes the value 1 if multi2nd == 1
# Z takes the value 0 if multi2nd == 0
PUMS80M$Z <- PUMS80M$multi2nd
# ======================================================================== #
# Define RX
# ======================================================================== #
# X takes the value 1 if whitem == 1
# X takes the value 2 if blackm == 1
# X takes the value 3 if othracem == 1
PUMS80M$X <- PUMS80M$whitem +
2*PUMS80M$blackm +
3*PUMS80M$othracem
# ======================================================================== #
# Select relevant data
# ======================================================================== #
Data <- data.frame(Y = PUMS80M$workedm,
D = PUMS80M$morekids,
X = PUMS80M$X,
Z = PUMS80M$Z)
rm(PUMS80M)
# ======================================================================== #
# Define probability space
# ======================================================================== #
library(plyr)
Grid <- expand.grid(unique(Data$Y),
unique(Data$D),
unique(Data$X),
unique(Data$Z))
colnames(Grid) <- c("Y","D","X","Z")
Calc <- function(j){
W = ifelse(Data$Y == Grid$Y[j] & Data$D == Grid$D[j],1,0)
V = ifelse(Data$X == Grid$X[j] & Data$Z == Grid$Z[j],1,0)
R <- lm(W ~ 0 + V)
return(R$coefficients[[1]])
}
Store <- vector(length = nrow(Grid))
for(j in 1:nrow(Grid)){
Store[j] = Calc(j)
}
Grid$f <- Store
rm(j)
rm(Store)
# ======================================================================== #
# Define bounds
# ======================================================================== #
Bounds.neg <- expand.grid(unique(Data$X),
unique(Data$Z))
colnames(Bounds.neg) <- c("X","Z")
Calc <- function(j){
A = vector(length = 4)
# Lower bound Y(0)
W = ifelse(Data$Y == 0,1,0)
V = ifelse(Data$X == Bounds.neg$X[j] & Data$Z == Bounds.neg$Z[j],1,0)
A[1] <- lm(W ~ 0 + V)$coefficients[[1]]
# Upper bound Y(0)
W = ifelse(Data$Y == 0 & Data$D == 0,0,1)
V = ifelse(Data$X == Bounds.neg$X[j] & Data$Z == Bounds.neg$Z[j],1,0)
A[2] <- lm(W ~ 0 + V)$coefficients[[1]]
# Lower bound Y(1)
W = ifelse(Data$Y == 1 & Data$D == 1,1,0)
V = ifelse(Data$X == Bounds.neg$X[j] & Data$Z == Bounds.neg$Z[j],1,0)
A[3] <- lm(W ~ 0 + V)$coefficients[[1]]
# Upper bound Y(1)
W = ifelse(Data$Y == 1,1,0)
V = ifelse(Data$X == Bounds.neg$X[j] & Data$Z == Bounds.neg$Z[j],1,0)
A[4] <- lm(W ~ 0 + V)$coefficients[[1]]
return(A)
}
Store <- matrix(nrow = nrow(Bounds.neg),ncol = 4)
for(j in 1:nrow(Bounds.neg)){
Store[j,] = Calc(j)
}
Bounds.neg$l0 <- Store[,1]
Bounds.neg$u0 <- Store[,2]
Bounds.neg$l1 <- Store[,3]
Bounds.neg$u1 <- Store[,4]
rm(j)
rm(Store)
# ======================================================================== #
# Define constraints
# ======================================================================== #
Set <- matrix(nrow = length(unique(Bounds.neg$X)), ncol = 5)
for(j in 1:length(unique(Bounds.neg$X))){
k = unique(Bounds.neg$X)[j]
Set[j,1] <- k
Set[j,2] <- max(Bounds.neg[Bounds.neg$X==k,"l0"])
Set[j,3] <- min(Bounds.neg[Bounds.neg$X==k,"u0"])
Set[j,4] <- max(Bounds.neg[Bounds.neg$X==k,"l1"])
Set[j,5] <- min(Bounds.neg[Bounds.neg$X==k,"u1"])
}
Constraints.neg <- as.data.frame(Set)
rm(Set)
colnames(Constraints.neg) <- c(colnames(Bounds.neg)[-2])
# ======================================================================== #
# Plot
# ======================================================================== #
Plot.data <- Constraints.neg[,1:4]
Plot.data <- melt(Plot.data, id=c("X","l1"))
Plot.data <- Plot.data[,-3]
ggplot(Plot.data, aes(y=l1,x=value,group=X)) +
geom_line(aes(col=X))
Constraints.neg
count(Data,"X")
count(Data,"X")/254654
count(Data,"X")$freq/254654
a <- c(0.5395,0.3191,0.5146)
(count(Data,"X")$freq/254654)*a
(count(Data,"X")$freq/254654)*t(a)
(count(Data,"X")$freq/254654)%*%a
a <- c(0.7217,0.8721,0.7786)
(count(Data,"X")$freq/254654)%*%a
